add_sub.c:         cpu_read_u8_at(c, base_offset(c->ds, c->si)), 
add_sub.c:         cpu_read_u8_at(c, base_offset(c->es, c->di)),
add_sub.c:         cpu_read_u16_at(c, base_offset(c->ds, c->si)), 
add_sub.c:         cpu_read_u16_at(c, base_offset(c->es, c->di)),
add_sub.c:      c->si -= update;
add_sub.c:      c->di -= update;
add_sub.c:      c->si += update;
add_sub.c:      c->di += update;
add_sub.c:         cpu_read_u8_at(c, base_offset(c->es, c->di)),
add_sub.c:         cpu_read_u16_at(c, base_offset(c->es, c->di)),
add_sub.c:   if(getDF(c)) c->di -= update;
add_sub.c:   else c->di += update;
flagops.c:   return (u8)((c->flags) & 0x0001);
flagops.c:   return (u8)(((c->flags) & 0x0004) >> 2);
flagops.c:   return (u8)(((c->flags) & 0x0010) >> 4);
flagops.c:   return (u8)(((c->flags) & 0x0040) >> 6);
flagops.c:   return (u8)(((c->flags) & 0x0080) >> 7);
flagops.c:   return (u8)(((c->flags) & 0x0100) >> 8);
flagops.c:   return (u8)(((c->flags) & 0x0200) >> 9);
flagops.c:   return (u8)(((c->flags) & 0x0400) >> 10);
flagops.c:   return (u8)(((c->flags) & 0x0800) >> 11);
flagops.c:void setCF(cpu* c) { c->flags |= 0x0001; }
flagops.c:void setPF(cpu* c) { c->flags |= 0x0004; }
flagops.c:void setAF(cpu* c) { c->flags |= 0x0010; }
flagops.c:void setZF(cpu* c) { c->flags |= 0x0040; }
flagops.c:void setSF(cpu* c) { c->flags |= 0x0080; }
flagops.c:void setTF(cpu* c) { c->flags |= 0x0100; }
flagops.c:void setIF(cpu* c) { c->flags |= 0x0200; }
flagops.c:void setDF(cpu* c) { c->flags |= 0x0400; }
flagops.c:void setOF(cpu* c) { c->flags |= 0x0800; }
flagops.c:void resetCF(cpu* c) { c->flags &= 0xfffe; }
flagops.c:void resetPF(cpu* c) { c->flags &= 0xfffb; }
flagops.c:void resetAF(cpu* c) { c->flags &= 0xffef; }
flagops.c:void resetZF(cpu* c) { c->flags &= 0xffbf; }
flagops.c:void resetSF(cpu* c) { c->flags &= 0xff7f; }
flagops.c:void resetTF(cpu* c) { c->flags &= 0xfeff; }
flagops.c:void resetIF(cpu* c) { c->flags &= 0xfdff; }
flagops.c:void resetDF(cpu* c) { c->flags &= 0xfbff; }
flagops.c:void resetOF(cpu* c) { c->flags &= 0xf7ff; }
inc_dec.c:         old_val = (u32)c->ax;
inc_dec.c:         new_val = (u32)c->ax + (u32)change1;
inc_dec.c:         c->ax = (c->ax & 0xff00) + (u8)(((c->ax & 0x00ff) + change1) & 0x00ff);
inc_dec.c:         old_val = c->ax;
inc_dec.c:         new_val = (u32)c->ax + (u32)change2;
inc_dec.c:         c->ax += change2;
inc_dec.c:         old_val = c->ax;
inc_dec.c:         new_val = (u32)c->ax + (u32)change1;
inc_dec.c:         c->ax += change1;
inc_dec.c:         old_val = c->bx;
inc_dec.c:         new_val = (u32)c->bx + (u32)change1;
inc_dec.c:         c->bx = (c->bx & 0xff00) + (u8)(((c->bx & 0x00ff) + change1) & 0x00ff);
inc_dec.c:         old_val = c->bx;
inc_dec.c:         new_val = (u32)c->bx + (u32)change2;
inc_dec.c:         c->bx += change2;
inc_dec.c:         old_val = c->bx;
inc_dec.c:         new_val = (u32)c->bx + (u32)change1;
inc_dec.c:         c->bx += change1;
inc_dec.c:         old_val = c->cx;
inc_dec.c:         new_val = (u32)c->cx + (u32)change1;
inc_dec.c:         c->cx = (c->cx & 0xff00) + (u8)(((c->cx & 0x00ff) + change1) & 0x00ff);
inc_dec.c:         old_val = c->cx;
inc_dec.c:         new_val = (u32)c->cx + (u32)change2;
inc_dec.c:         c->cx += change2;
inc_dec.c:         old_val = c->cx;
inc_dec.c:         new_val = (u32)c->cx + (u32)change1;
inc_dec.c:         c->cx += change1;
inc_dec.c:         old_val = c->dx;
inc_dec.c:         new_val = (u32)c->dx + (u32)change1;
inc_dec.c:         c->dx = (c->dx & 0xff00) + (u8)(((c->dx & 0x00ff) + change1) & 0x00ff);
inc_dec.c:         old_val = c->dx;
inc_dec.c:         new_val = (u32)c->dx + (u32)change2;
inc_dec.c:         c->dx += change2;
inc_dec.c:         old_val = c->dx;
inc_dec.c:         new_val = (u32)c->dx + (u32)change1;
inc_dec.c:         c->dx += change1;
inc_dec.c:         old_val = c->si;
inc_dec.c:         new_val = (u32)c->si + (u32)change1;
inc_dec.c:         c->si += change1;
inc_dec.c:         old_val = c->di;
inc_dec.c:         new_val = (u32)c->di + (u32)change1;
inc_dec.c:         c->di += change1;
inc_dec.c:         old_val = c->sp;
inc_dec.c:         new_val = (u32)c->sp + (u32)change1;
inc_dec.c:         c->sp += change1;
inc_dec.c:         old_val = c->bp;
inc_dec.c:         new_val = (u32)c->bp + (u32)change1;
inc_dec.c:         c->bp += change1;
cpu.c:    case  0: return base_offset(base_segment, c->bx + c->si);
cpu.c:    case  1: return base_offset(base_segment, c->bx + c->di);
cpu.c:    case  2: return base_offset(base_segment, c->bp + c->si);
cpu.c:    case  3: return base_offset(base_segment, c->bp + c->di);
cpu.c:    case  4: return base_offset(base_segment, c->si);
cpu.c:    case  5: return base_offset(base_segment, c->di);
cpu.c:    case  7: return base_offset(base_segment, c->bx);
cpu.c:    case  8: case 16: return base_offset(base_segment, c->bx + c->si + offset);
cpu.c:    case  9: case 17: return base_offset(base_segment, c->bx + c->di + offset);
cpu.c:    case 10: case 18: return base_offset(base_segment, c->bp + c->si + offset);
cpu.c:    case 11: case 19: return base_offset(base_segment, c->bp + c->di + offset);
cpu.c:    case 12: case 20: return base_offset(base_segment, c->si + offset);
cpu.c:    case 13: case 21: return base_offset(base_segment, c->di + offset);
cpu.c:    case 14: case 22: return base_offset(base_segment, c->bp + offset);
cpu.c:    case 15: case 23: return base_offset(base_segment, c->bx + offset);
cpu.c:   case AL: c->ax = (c->ax & 0xff00) + val; break;
cpu.c:   case BL: c->bx = (c->bx & 0xff00) + val; break;
cpu.c:   case CL: c->cx = (c->cx & 0xff00) + val; break;
cpu.c:   case DL: c->dx = (c->dx & 0xff00) + val; break;
cpu.c:   case AH: c->ax = (c->ax & 0x00ff) + (val << 8); break;
cpu.c:   case BH: c->bx = (c->bx & 0x00ff) + (val << 8); break;
cpu.c:   case CH: c->cx = (c->cx & 0x00ff) + (val << 8); break;
cpu.c:   case DH: c->dx = (c->dx & 0x00ff) + (val << 8); break;
cpu.c:   case AX: c->ax = val; break;
cpu.c:   case CX: c->cx = val; break;
cpu.c:   case DX: c->dx = val; break;
cpu.c:   case BX: c->bx = val; break;
cpu.c:   case SP: c->sp = val; break;
cpu.c:   case BP: c->bp = val; break;
cpu.c:   case SI: c->si = val; break;
cpu.c:   case DI: c->di = val; break;
cpu.c:   case CS: c->cs = val; break;
cpu.c:   case DS: c->ds = val; break;
cpu.c:   case ES: c->es = val; break;
cpu.c:   case SS: c->ss = val; break;
cpu.c:   case AL: val = (u8)(c->ax & 0x00ff); break;
cpu.c:   case BL: val = (u8)(c->bx & 0x00ff); break;
cpu.c:   case CL: val = (u8)(c->cx & 0x00ff); break;
cpu.c:   case DL: val = (u8)(c->dx & 0x00ff); break;
cpu.c:   case AH: val = (u8)((c->ax & 0xff00) >> 8); break;
cpu.c:   case BH: val = (u8)((c->bx & 0xff00) >> 8); break;
cpu.c:   case CH: val = (u8)((c->cx & 0xff00) >> 8); break;
cpu.c:   case DH: val = (u8)((c->dx & 0xff00) >> 8); break;
cpu.c:   case AX: return c->ax;
cpu.c:   case CX: return c->cx;
cpu.c:   case DX: return c->dx;
cpu.c:   case BX: return c->bx;
cpu.c:   case SP: return c->sp;
cpu.c:   case BP: return c->bp;
cpu.c:   case SI: return c->si;
cpu.c:   case DI: return c->di;
cpu.c:   case CS: return c->cs;
cpu.c:   case DS: return c->ds;
cpu.c:   case ES: return c->es;
cpu.c:   case SS: return c->ss;
cpu.c:   case FLG: return c->flags;
cpu.c:   *next = cpu_read_u8_at(c, base_offset(c->cs, c->ip));
cpu.c:   (c->ip)++;
cpu.c:      *offset = cpu_read_u16_at(c, base_offset(c->cs, c->ip));
cpu.c:      (c->ip) += 2;
cpu.c:      *offset = cpu_read_u8_at(c, base_offset(c->cs, c->ip));
cpu.c:      (c->ip) += 1;
cpu.c:      case 0x26: return c->es;
cpu.c:      case 0x2e: return c->cs;
cpu.c:      case 0x36: return c->ss;
cpu.c:      case 0x3e: return c->ds;
cpu.c:      case IP: return c->cs;
cpu.c:      case SP: return c->ss;
cpu.c:      case BP: return c->ss;
cpu.c:      case BX: return c->ds;
cpu.c:      case DI: return c->ds;
cpu.c:      case SI: return c->ds;
cpu.c:      case 6: return c->ds;
cpu.c:   c->flags &= 0xff00;
cpu.c:   c->flags += get_reg8_val(c, AH);
cpu.c:   set_reg8(c, AH, (u8)(c->flags & 0x00ff));
cpu.c:   set_reg16(c, r, c->ax);
cpu.c:   c->ax = temp;
cpu.c:         c->ds, 
cpu.c:         (c->bx + get_reg8_val(c, AL)))
cpu.c:   data = c->mem[addr];
cpu.c:   return (c->iop)[port];
cpu.c:   (c->iop)[port] = val;
cpu.c:   c->iop[port] = (u8)(data & 0xff);
cpu.c:   c->iop[port + 1] = (u8)((data & 0xff00) >> 8);
cpu.c:   data = c->mem[addr];
cpu.c:   data = data + ((c->mem[addr + 1]) << 8);
cpu.c:      (c->iop)[port],
cpu.c:      (c->iop)[port + 1]
cpu.c:   c->mem[addr] = data;
cpu.c:   c->mem[addr] = (u8)(data & 0xff);
cpu.c:   c->mem[addr + 1] = (u8)((data & 0xff00) >> 8);
cpu.c:   c->ax = 0;
cpu.c:   c->bx = 0;
cpu.c:   c->cx = 0;
cpu.c:   c->dx = 0;
cpu.c:   c->sp = 0;
cpu.c:   c->bp = 0;
cpu.c:   c->si = 0;
cpu.c:   c->di = 0;
cpu.c:   c->flags = 0;
cpu.c:   c->halted = 0;
cpu.c:   c->mem = (u8*) malloc(sizeof(u8) * MAX_MEMORY);
cpu.c:   c->iop = (u8*) malloc(sizeof(u8) * IO_MEMORY);
cpu.c:      if(c->mem != NULL) free(c->mem);
cpu.c:      if(c->iop != NULL) free(c->iop);
cpu.c:   c->cs = cs;
cpu.c:   c->ds = ds;
cpu.c:   c->ss = ss;
cpu.c:   c->es = es;
cpu.c:   c->cs = CS_START;
cpu.c:   c->ds = DS_START;
cpu.c:   c->ss = SS_START;
cpu.c:   c->es = ES_START;
cpu.c:   c->mem = mem;
cpu.c:   c->iop = iop;
cpu.c:   byte = cpu_read_u8_at(c, base_offset(c->cs, c->ip));
cpu.c:         (c->ip)++;
cpu.c:         (c->ip)++;
cpu.c:         addr = base_offset(c->cs, c->ip);
cpu.c:         (c->ip)++;
cpu.c:         addr = base_offset(c->cs, c->ip);
cpu.c:         (c->ip)+=2;
cpu.c:         addr = base_offset(c->cs, c->ip);
cpu.c:         (c->ip)++;
cpu.c:         addr = base_offset(c->cs, c->ip);
cpu.c:         (c->ip)+=2;
cpu.c:         addr = base_offset(c->cs, c->ip);
cpu.c:         (c->ip)++;
cpu.c:         addr = base_offset(c->cs, c->ip);
cpu.c:         (c->ip)+=2;
cpu.c:         addr = base_offset(c->cs, c->ip);
cpu.c:         (c->ip)++;
cpu.c:         addr = base_offset(c->cs, c->ip);
cpu.c:         (c->ip)+=2;
cpu.c:         addr = base_offset(c->cs, c->ip);
cpu.c:         (c->ip)++;
cpu.c:         addr = base_offset(c->cs, c->ip);
cpu.c:         (c->ip)+=2;
cpu.c:         addr = base_offset(c->cs, c->ip);
cpu.c:         (c->ip)++;
cpu.c:         addr = base_offset(c->cs, c->ip);
cpu.c:         (c->ip)+=2;
cpu.c:         addr = base_offset(c->cs, c->ip);
cpu.c:         (c->ip)++;
cpu.c:         addr = base_offset(c->cs, c->ip);
cpu.c:         (c->ip)+=2;
cpu.c:         addr = base_offset(c->cs, c->ip);
cpu.c:         (c->ip)++;
cpu.c:         addr = base_offset(c->cs, c->ip);
cpu.c:         (c->ip)+=2;
cpu.c:         next = cpu_read_u8_at(c, base_offset(c->cs, c->ip));
cpu.c:         (c->ip)++;
cpu.c:         next = cpu_read_u8_at(c, base_offset(c->cs, c->ip));
cpu.c:         (c->ip)++;
cpu.c:      case 0xb0: mov_r8i(c, AL, cpu_read_u8_at(c, base_offset(c->cs, c->ip))); (c->ip)++; break;
cpu.c:      case 0xb1: mov_r8i(c, CL, cpu_read_u8_at(c, base_offset(c->cs, c->ip))); (c->ip)++; break;
cpu.c:      case 0xb2: mov_r8i(c, DL, cpu_read_u8_at(c, base_offset(c->cs, c->ip))); (c->ip)++; break;
cpu.c:      case 0xb3: mov_r8i(c, BL, cpu_read_u8_at(c, base_offset(c->cs, c->ip))); (c->ip)++; break;
cpu.c:      case 0xb4: mov_r8i(c, AH, cpu_read_u8_at(c, base_offset(c->cs, c->ip))); (c->ip)++; break;
cpu.c:      case 0xb5: mov_r8i(c, CH, cpu_read_u8_at(c, base_offset(c->cs, c->ip))); (c->ip)++; break;
cpu.c:      case 0xb6: mov_r8i(c, DH, cpu_read_u8_at(c, base_offset(c->cs, c->ip))); (c->ip)++; break;
cpu.c:      case 0xb7: mov_r8i(c, BH, cpu_read_u8_at(c, base_offset(c->cs, c->ip))); (c->ip)++; break;
cpu.c:      case 0xb8: mov_r16i(c, AX, cpu_read_u16_at(c, base_offset(c->cs, c->ip))); (c->ip)+=2; break;
cpu.c:      case 0xb9: mov_r16i(c, CX, cpu_read_u16_at(c, base_offset(c->cs, c->ip))); (c->ip)+=2; break;
cpu.c:      case 0xba: mov_r16i(c, DX, cpu_read_u16_at(c, base_offset(c->cs, c->ip))); (c->ip)+=2; break;
cpu.c:      case 0xbb: mov_r16i(c, BX, cpu_read_u16_at(c, base_offset(c->cs, c->ip))); (c->ip)+=2; break;
cpu.c:      case 0xbc: mov_r16i(c, SP, cpu_read_u16_at(c, base_offset(c->cs, c->ip))); (c->ip)+=2; break;
cpu.c:      case 0xbd: mov_r16i(c, BP, cpu_read_u16_at(c, base_offset(c->cs, c->ip))); (c->ip)+=2; break;
cpu.c:      case 0xbe: mov_r16i(c, SI, cpu_read_u16_at(c, base_offset(c->cs, c->ip))); (c->ip)+=2; break;
cpu.c:      case 0xbf: mov_r16i(c, DI, cpu_read_u16_at(c, base_offset(c->cs, c->ip))); (c->ip)+=2; break;
cpu.c:         src_val = cpu_read_u16_at(c, base_offset(c->cs, c->ip));
cpu.c:         (c->ip)+=2;
cpu.c:                  :  c->ds,
cpu.c:         src_val = cpu_read_u16_at(c, base_offset(c->cs, c->ip));
cpu.c:         (c->ip)+=2;
cpu.c:                  :  c->ds,
cpu.c:         src_val = cpu_read_u16_at(c, base_offset(c->cs, c->ip));
cpu.c:         (c->ip)+=2;
cpu.c:                  :  c->ds,
cpu.c:         src_val = cpu_read_u16_at(c, base_offset(c->cs, c->ip));
cpu.c:         (c->ip)+=2;
cpu.c:                  :  c->ds,
cpu.c:                  base_offset(c->cs, c->ip))
cpu.c:            (c->ip)++;
cpu.c:                  base_offset(c->cs, c->ip))
cpu.c:            (c->ip)+=2;
cpu.c:         next = cpu_read_u8_at(c, base_offset(c->cs, c->ip));
cpu.c:         (c->ip)++;
cpu.c:               offset = cpu_read_u16_at(c, base_offset(c->cs, c->ip));
cpu.c:               (c->ip) += 2;
cpu.c:               offset = cpu_read_u8_at(c, base_offset(c->cs, c->ip));
cpu.c:               (c->ip) += 1;
cpu.c:            addr = base_offset(c->cs, c->ip);
cpu.c:            addr = base_offset(c->cs, c->ip);
cpu.c:         next = cpu_read_u8_at(c, base_offset(c->cs, c->ip));
cpu.c:         (c->ip)++;
cpu.c:                  if(c->sp < 0xfffe) c->sp += 2; else break;
cpu.c:                  mov_rm(c, other_reg, base_offset(c->ss, c->sp - 2));
cpu.c:                     offset = cpu_read_u16_at(c, base_offset(c->cs, c->ip));
cpu.c:                     (c->ip) += 2;
cpu.c:                     offset = cpu_read_u8_at(c, base_offset(c->cs, c->ip));
cpu.c:                     (c->ip) += 1;
cpu.c:                  if (c->sp < 0xfffe) c->sp += 2; else break;
cpu.c:                  src_val = cpu_read_u16_at(c, base_offset(c->ss, c->sp - 2));
cpu.c:         if(BIT(7, c->ax)) set_reg8(c, AH, 0xff);
cpu.c:         if(BIT(15, c->ax)) c->dx = 0xffff;
cpu.c:         else c->dx = 0x0000;
cpu.c:      case 0xf4: c->halted = 1;  break;
cpu.c:         addr = base_offset(c->cs, c->ip);
cpu.c:         (c->ip)++;
cpu.c:         addr = base_offset(c->cs, c->ip);
cpu.c:         (c->ip)+=2;
cpu.c:            addr = base_offset(c->cs, c->ip);
cpu.c:            (c->ip)++;
cpu.c:            addr = base_offset(c->cs, c->ip);
cpu.c:            (c->ip)++;
cpu.c:            addr = base_offset(c->cs, c->ip);
cpu.c:            (c->ip)+=2;
cpu.c:            addr = base_offset(c->cs, c->ip);
cpu.c:            (c->ip)+=2;
cpu.c:            addr = base_offset(c->cs, c->ip);
cpu.c:               default: (c->ip)--; /* Just to counter the ip++ that happens after the if. */
cpu.c:            (c->ip)++;
cpu.c:            addr = base_offset(c->cs, c->ip);
cpu.c:               default: (c->ip)--; /* Just to counter the ip++ that happens after the if. */
cpu.c:            (c->ip)++;
cpu.c:            addr = base_offset(c->cs, c->ip);
cpu.c:            (c->ip)+=1;
cpu.c:            addr = base_offset(c->cs, c->ip);
cpu.c:            (c->ip)+=1;
cpu.c:      case 0x70: jump_short(c,  getOF(c), cpu_read_u8_at(c, base_offset(c->cs, c->ip))); (c->ip)++; break;
cpu.c:      case 0x71: jump_short(c, !getOF(c), cpu_read_u8_at(c, base_offset(c->cs, c->ip))); (c->ip)++; break;
cpu.c:      case 0x72: jump_short(c,  getCF(c), cpu_read_u8_at(c, base_offset(c->cs, c->ip))); (c->ip)++; break;
cpu.c:      case 0x73: jump_short(c, !getCF(c), cpu_read_u8_at(c, base_offset(c->cs, c->ip))); (c->ip)++; break;
cpu.c:      case 0x74: jump_short(c,  getZF(c), cpu_read_u8_at(c, base_offset(c->cs, c->ip))); (c->ip)++; break;
cpu.c:      case 0x75: jump_short(c, !getZF(c), cpu_read_u8_at(c, base_offset(c->cs, c->ip))); (c->ip)++; break;
cpu.c:      case 0x76: jump_short(c,  (getCF(c) || getZF(c)), cpu_read_u8_at(c, base_offset(c->cs, c->ip))); (c->ip)++; break;
cpu.c:      case 0x77: jump_short(c, !(getCF(c) || getZF(c)), cpu_read_u8_at(c, base_offset(c->cs, c->ip))); (c->ip)++; break;
cpu.c:      case 0x78: jump_short(c,  getSF(c), cpu_read_u8_at(c, base_offset(c->cs, c->ip))); (c->ip)++; break;
cpu.c:      case 0x79: jump_short(c, !getSF(c), cpu_read_u8_at(c, base_offset(c->cs, c->ip))); (c->ip)++; break;
cpu.c:      case 0x7a: jump_short(c,  getPF(c), cpu_read_u8_at(c, base_offset(c->cs, c->ip))); (c->ip)++; break;
cpu.c:      case 0x7b: jump_short(c, !getPF(c), cpu_read_u8_at(c, base_offset(c->cs, c->ip))); (c->ip)++; break;
cpu.c:      case 0x7c: jump_short(c, (getSF(c) != getOF(c)), cpu_read_u8_at(c, base_offset(c->cs, c->ip))); (c->ip)++; break;
cpu.c:      case 0x7d: jump_short(c, (getSF(c) == getOF(c)), cpu_read_u8_at(c, base_offset(c->cs, c->ip))); (c->ip)++; break;
cpu.c:      case 0x7e: jump_short(c,  (getZF(c) || (getSF(c) != getOF(c))), cpu_read_u8_at(c, base_offset(c->cs, c->ip))); (c->ip)++; break;
cpu.c:      case 0x7f: jump_short(c, (!getZF(c) || (getSF(c) == getOF(c))), cpu_read_u8_at(c, base_offset(c->cs, c->ip))); (c->ip)++; break;
cpu.c:      case 0xe3: jump_short(c, (get_reg16_val(c, CX) == 0), cpu_read_u8_at(c, base_offset(c->cs, c->ip))); (c->ip)++; break;
cpu.c:      case 0xe9: jump_near (c, 1, cpu_read_u16_at(c, base_offset(c->cs, c->ip))); (c->ip)+=2; break;
cpu.c:      case 0xeb: jump_short(c, 1, cpu_read_u8_at (c, base_offset(c->cs, c->ip))); (c->ip)++; break;
cpu.c:            cpu_read_u16_at(c, base_offset(c->cs, c->ip)), 
cpu.c:            cpu_read_u16_at(c, base_offset(c->cs, (c->ip + 2)))
cpu.c:         (c->ip)+=4; 
cpu.c:         next = cpu_read_u8_at(c, base_offset(c->cs, c->ip));
cpu.c:         (c->ip)++;
cpu.c:         while (c->cx != 0) {
cpu.c:            (c->cx)--;
cpu.c:         next = cpu_read_u8_at(c, base_offset(c->cs, c->ip));
cpu.c:         (c->ip)++;
cpu.c:         while (c->cx != 0) {
cpu.c:            (c->cx)--;
cpu.c:            addr = base_offset(c->cs, c->ip);
cpu.c:                  (c->ip)++;
cpu.c:            addr = base_offset(c->cs, c->ip);
cpu.c:                  (c->ip)++;
cpu.c:            addr = base_offset(c->cs, c->ip);
cpu.c:                  (c->ip)+=2;
cpu.c:            addr = base_offset(c->cs, c->ip);
cpu.c:                  (c->ip)+=2;
cpu.c:      case 0xe0: loop_short(c, (getZF(c) == 0), cpu_read_u8_at(c, base_offset(c->cs, c->ip))); (c->ip)++; break;
cpu.c:      case 0xe1: loop_short(c,  getZF(c), cpu_read_u8_at(c, base_offset(c->cs, c->ip))); (c->ip)++; break;
cpu.c:      case 0xe2: loop_short(c,  1, cpu_read_u8_at(c, base_offset(c->cs, c->ip))); (c->ip)++; break;
cpu.c:         addr = base_offset(c->cs, c->ip);
cpu.c:         (c->ip)++;
cpu.c:         addr = base_offset(c->cs, c->ip);
cpu.c:         (c->ip)++;
cpu.c:         addr = base_offset(c->cs, c->ip);
cpu.c:         addr = base_offset(c->cs, c->ip);
cpu.c:         offset = cpu_read_u16_at(c, base_offset(c->cs, c->ip));
cpu.c:         (c->ip)+=2;
cpu.c:         src_val = cpu_read_u16_at(c, base_offset(c->cs, c->ip));
cpu.c:         (c->ip)+=2;
cpu.c:      /* in this context, src->val => ip increment */
cpu.c:         src_val = cpu_read_u16_at(c, base_offset(c->cs, c->ip));
cpu.c:         (c->ip)+=2;
cpu.c:               base_offset(c->cs, c->ip)));
cpu.c:         (c->ip)+=2;
cpu.c:               base_offset(c->cs, c->ip)));
cpu.c:         (c->ip)+=2;
cpu.c:   printf("\nAX: %4x H     SP: %4x H\n",   c->ax, c->sp);
cpu.c:   printf(  "BX: %4x H     BP: %4x H\n",   c->bx, c->bp);
cpu.c:   printf(  "CX: %4x H     SI: %4x H\n",   c->cx, c->si);
cpu.c:   printf(  "DX: %4x H     DI: %4x H\n",   c->dx, c->di);
cpu.c:   printf(  "CS: %4x H\n",   c->cs);
cpu.c:   printf(  "DS: %4x H\n",   c->ds);
cpu.c:   printf(  "ES: %4x H\n",   c->es);
cpu.c:   printf(  "SS: %4x H\n", c->ss);
cpu.c:   printf(  "FL: %4x H\n\n", c->flags);
cpu.c:   if(c->mem == NULL) printf("Memory not initialised.\n");
cpu.c:         printf("%3x", c->mem[i]);
jumps.c:      c->ip += ip_inc;
jumps.c:      c->ip += ip_inc;
jumps.c:      c->ip = at_ip;
jumps.c:      c->cs = at_cs;
jumps.c:   (c->cx)--;
jumps.c:   if (c->cx != 0 && condition) {
jumps.c:      c->ip += ip_inc;
jumps.c:   push16(c, c->ip); 
jumps.c:   c->ip += ip_inc;
jumps.c:   push16(c, c->ip); 
jumps.c:   c->ip = ip;
jumps.c:   push16(c, c->cs); 
jumps.c:   push16(c, c->ip);
jumps.c:   c->ip = ip;
jumps.c:   c->cs = cs;
jumps.c:   (c->sp)+=offset;
jumps.c:   (c->sp)+=offset;
memory.c:   if (c->mem == NULL) {
memory.c:      c->mem = (u8*)malloc(sizeof(u8)*MAX_MEMORY);
memory.c:   for (; i < c->cs; i++) c->mem[i] = (u8)0;
memory.c:   i = c->cs;
memory.c:      c->mem[i] = file[i]; i++;
memory.c:   for (; (u32)i < MAX_MEMORY; i++) c->mem[i] = (u8)0;
move.c:   case AX: c->ax = val; break;
move.c:   case BX: c->bx = val; break;
move.c:   case CX: c->cx = val; break;
move.c:   case DX: c->dx = val; break;
move.c:   case SP: c->sp = val; break;
move.c:   case BP: c->bp = val; break;
move.c:   case SI: c->si = val; break;
move.c:   case DI: c->di = val; break;
move.c:   case ES: c->es = val; break;
move.c:   case CS: c->cs = val; break;
move.c:   case SS: c->ss = val; break;
move.c:   case DS: c->ds = val; break;
move.c:   case FLG: c->flags = val; break;
move.c:      case AL: c->ax = (c->ax & 0xff00) + (u16)val; break;
move.c:      case CL: c->cx = (c->cx & 0xff00) + (u16)val; break;
move.c:      case DL: c->dx = (c->dx & 0xff00) + (u16)val; break;
move.c:      case BL: c->bx = (c->bx & 0xff00) + (u16)val; break;
move.c:      case AH: c->ax = (c->ax & 0xff) + ((u16)val << 8); break;
move.c:      case CH: c->cx = (c->cx & 0xff) + ((u16)val << 8); break;
move.c:      case DH: c->dx = (c->dx & 0xff) + ((u16)val << 8); break;
move.c:      case BH: c->bx = (c->bx & 0xff) + ((u16)val << 8); break;
move.c:      case AX: src_val = c->ax; break;
move.c:      case CX: src_val = c->cx; break;
move.c:      case DX: src_val = c->dx; break;
move.c:      case BX: src_val = c->bx; break;
move.c:      case ES: src_val = c->es; break;
move.c:      case CS: src_val = c->cs; break;
move.c:      case SS: src_val = c->ss; break;
move.c:      case DS: src_val = c->ds; break;
move.c:      case AL: src_val = (u8)(c->ax & 0xff); break;
move.c:      case CL: src_val = (u8)(c->cx & 0xff); break;
move.c:      case DL: src_val = (u8)(c->dx & 0xff); break;
move.c:      case BL: src_val = (u8)(c->bx & 0xff); break;
move.c:      case AH: src_val = (u8)((c->ax & 0xff00) >> 8); break;
move.c:      case CH: src_val = (u8)((c->cx & 0xff00) >> 8); break;
move.c:      case DH: src_val = (u8)((c->dx & 0xff00) >> 8); break;
move.c:      case BH: src_val = (u8)((c->bx & 0xff00) >> 8); break;
move.c:      src_u8 = (u8)(c->ax & 0xff);
move.c:      src_u8 = (u8)(c->bx & 0xff);
move.c:      src_u8 = (u8)(c->cx & 0xff);
move.c:      src_u8 = (u8)(c->dx & 0xff);
move.c:      src_u8 = (u8)((c->ax & 0xff00) >> 8);
move.c:      src_u8 = (u8)((c->bx & 0xff00) >> 8);
move.c:      src_u8 = (u8)((c->cx & 0xff00) >> 8);
move.c:      src_u8 = (u8)((c->dx & 0xff00) >> 8);
move.c:      cpu_write_u16_at(c, addr, c->ax);
move.c:      cpu_write_u16_at(c, addr, c->bx);
move.c:      cpu_write_u16_at(c, addr, c->cx);
move.c:      cpu_write_u16_at(c, addr, c->dx);
move.c:      cpu_write_u16_at(c, addr, c->si);
move.c:      cpu_write_u16_at(c, addr, c->di);
move.c:      cpu_write_u16_at(c, addr, c->sp);
move.c:      cpu_write_u16_at(c, addr, c->bp);
move.c:      cpu_write_u16_at(c, addr, c->ip);
move.c:      cpu_write_u16_at(c, addr, c->es);
move.c:      cpu_write_u16_at(c, addr, c->cs);
move.c:      cpu_write_u16_at(c, addr, c->ss);
move.c:      cpu_write_u16_at(c, addr, c->ds);
move.c:         base_offset(c->es, c->di), 
move.c:         base_offset(c->es, c->di), 
move.c:   if(getDF(c)) c->di -= update;
move.c:   else c->di += update;
move.c:         cpu_read_u8_at(c, base_offset(c->ds, c->si))
move.c:         cpu_read_u16_at(c, base_offset(c->ds, c->si))
move.c:   if(getDF(c)) c->si -= update;
move.c:   else c->si += update;
move.c:         base_offset(c->es, c->di),
move.c:         cpu_read_u8_at(c, base_offset(c->ds, c->si))
move.c:         base_offset(c->es, c->di),
move.c:         cpu_read_u16_at(c, base_offset(c->ds, c->si))
move.c:      c->si -= update; 
move.c:      c->di -= update; 
move.c:      c->si += update;
move.c:      c->di += update;
push_pop.c:   if (c->sp > 1) c->sp -= 2; else return;
push_pop.c:   cpu_write_u16_at(c, base_offset(c->ss, c->sp), val);
push_pop.c:   if(c->sp < 0xfffe) c->sp += 2; else return;
push_pop.c:   mov_rm(c, r, base_offset(c->ss, c->sp - 2));
push_pop.c:   if (c->sp > 0) c->sp--; else return;
push_pop.c:   cpu_write_u8_at(c, base_offset(c->ss, c->sp), val);
push_pop.c:   if(c->sp < 0xffff) c->sp++; else return -1;
push_pop.c:   return cpu_read_u8_at(c, base_offset(c->ss, c->sp - 1));
push_pop.c:   if (c->sp > 1) c->sp-=2; else return;
push_pop.c:   cpu_write_u16_at(c, base_offset(c->ss, c->sp), val);
push_pop.c:   if(c->sp < 0xfffe) c->sp+=2; else return -1;
push_pop.c:   return cpu_read_u16_at(c, base_offset(c->ss, c->sp - 2));
